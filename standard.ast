------------------------------------------------------------------
-- standard.ast
--
-- this module implements the standard interpretation for all
-- builtin operator symbols.
--
-- this module also defines some standard functions, e.g., eval
--
-- (c) Lutz Hamel, University of Rhode Island
------------------------------------------------------------------
-- NOTE: escaped Python code can return a value to the parent
--       Asteroid code via the __retval__ return value register.
--       For examples see code below.
------------------------------------------------------------------
-- arithmetic operators --
--
-- 'promote' is the type promotion table for primitive
-- builtin types which implements the type hierarchy:
--
--          integer < real < string and list
------------------------------------------------------------------
function add_op with a, b do return escape 
"
global __retval__ 

val_a = state.symbol_table.lookup_sym('a')
val_b = state.symbol_table.lookup_sym('b')

type = promote(val_a[0], val_b[0])

if type in ['integer', 'real', 'string', 'list']:
    __retval__ = (type, val_a[1] + val_b[1])

else:
    raise ValueError('unsupported type {} in +'.format(type))
"     
end function

------------------------------------------------------------------
attach add_op to __plus__.

------------------------------------------------------------------
function subtract_op with a, b do return escape 
"
global __retval__ 

val_a = state.symbol_table.lookup_sym('a')
val_b = state.symbol_table.lookup_sym('b')

type = promote(val_a[0], val_b[0])

if type in ['integer', 'real']:
    __retval__ = (type, val_a[1] - val_b[1])

else:
    raise ValueError('unsupported type {} in -'.format(type))
"     
end function

------------------------------------------------------------------
attach subtract_op to __minus__.

------------------------------------------------------------------
function mult_op with a, b do return escape 
"
global __retval__

val_a = state.symbol_table.lookup_sym('a')
val_b = state.symbol_table.lookup_sym('b')

type = promote(val_a[0], val_b[0])

if type in ['integer', 'real']:
    __retval__ = (type, val_a[1] * val_b[1])

else:
    raise ValueError('unsupported type in *')
"     
end function

------------------------------------------------------------------
attach mult_op to __times__.

------------------------------------------------------------------
function divide_op with a, b do return escape 
"
global __retval__

val_a = state.symbol_table.lookup_sym('a')
val_b = state.symbol_table.lookup_sym('b')

type = promote(val_a[0], val_b[0])

if type == 'integer':
    __retval__ = (type, int(val_a[1]) // int(val_b[1]))

elif type == 'real':
    __retval__ = ('real', float(val_a[1]) / float(val_b[1]))

else:
    raise ValueError('unsupported type in /')
"     
end function

------------------------------------------------------------------
attach divide_op to __divide__.

------------------------------------------------------------------
-- logic operators
------------------------------------------------------------------
function and_op with a, b do return escape 
"
global __retval__ 

b1 = map2boolean(state.symbol_table.lookup_sym('a')) 
b2 = map2boolean(state.symbol_table.lookup_sym('b')) 

if b1[1] == True and b2[1] == True:
   __retval__ = ('boolean', True)

else:
   __retval__ = ('boolean', False)
"     
end function

------------------------------------------------------------------
attach and_op to __and__.

------------------------------------------------------------------
function or_op with a, b do return escape 
"
global __retval__ 

b1 = map2boolean(state.symbol_table.lookup_sym('a')) 
b2 = map2boolean(state.symbol_table.lookup_sym('b')) 

if b1[1] == False and b2[1] == False:
   __retval__ = ('boolean', False)

else:
   __retval__ = ('boolean', True)
"     
end function

------------------------------------------------------------------
attach or_op to __or__.

------------------------------------------------------------------
-- relational operators
------------------------------------------------------------------
function eq_op with a, b do return escape 
"
global __retval__ 

val_a = state.symbol_table.lookup_sym('a')
val_b = state.symbol_table.lookup_sym('b')

type = promote(val_a[0], val_b[0])

if type in ['integer', 'real', 'list', 'string']:
    __retval__ = ('boolean', val_a[1] == val_b[1])

else:
    raise ValueError('unsupported type in ==')
"     
end function

------------------------------------------------------------------
attach eq_op to __eq__.
------------------------------------------------------------------
function ne_op with a, b do return escape 
"
global __retval__ 

val_a = state.symbol_table.lookup_sym('a')
val_b = state.symbol_table.lookup_sym('b')

type = promote(val_a[0], val_b[0])

if type in ['integer', 'real', 'list', 'string']:
    __retval__ = ('boolean', val_a[1] != val_b[1])

else:
    raise ValueError('unsupported type in =/=')
"     
end function

------------------------------------------------------------------
attach ne_op to __ne__.

------------------------------------------------------------------
function le_op with a, b do return escape 
"
global __retval__ 

val_a = state.symbol_table.lookup_sym('a')
val_b = state.symbol_table.lookup_sym('b')

type = promote(val_a[0], val_b[0])

if type in ['integer', 'real']:
    __retval__ = ('boolean', val_a[1] <= val_b[1])

else:
    raise ValueError('unsupported type in <=')
"     
end function

------------------------------------------------------------------
attach le_op to __le__.

------------------------------------------------------------------
function lt_op with a, b do return escape 
"
global __retval__ 

val_a = state.symbol_table.lookup_sym('a')
val_b = state.symbol_table.lookup_sym('b')

type = promote(val_a[0], val_b[0])

if type in ['integer', 'real']:
    __retval__ = ('boolean', val_a[1] < val_b[1])

else:
    raise ValueError('unsupported type in <')
"     
end function

------------------------------------------------------------------
attach lt_op to __lt__.

------------------------------------------------------------------
function ge_op with a, b do return escape 
"
global __retval__ 

val_a = state.symbol_table.lookup_sym('a')
val_b = state.symbol_table.lookup_sym('b')

type = promote(val_a[0], val_b[0])

if type in ['integer', 'real']:
    __retval__ = ('boolean', val_a[1] >= val_b[1])

else:
    raise ValueError('unsupported type in >=')
"     
end function

------------------------------------------------------------------
attach ge_op to __ge__.

------------------------------------------------------------------
function gt_op with a, b do return escape 
"
global __retval__ 

val_a = state.symbol_table.lookup_sym('a')
val_b = state.symbol_table.lookup_sym('b')


type = promote(val_a[0], val_b[0])


if type in ['integer', 'real']:
    __retval__ = ('boolean', val_a[1] > val_b[1])

else:
    raise ValueError('unsupported type in >')
"     
end function

------------------------------------------------------------------
attach gt_op to __gt__.

------------------------------------------------------------------
-- unary ops
------------------------------------------------------------------
function uminus_op with a do return escape 
"
global __retval__ 

val_a = state.symbol_table.lookup_sym('a')

if val_a[0] in ['integer', 'real']:
    __retval__ = (val_a[0], - val_a[1])

else:
    raise ValueError('unsupported type in unary minus')
"     
end function

------------------------------------------------------------------
attach uminus_op to __uminus__.

------------------------------------------------------------------
function not_op with a do return escape 
"
global __retval__ 

val_a = state.symbol_table.lookup_sym('a')

bool_a = map2boolean(val_a)

if val_a[1] == False:
    __retval__ = ('boolean', True)

elif val_a[1] == True:
    __retval__ = ('boolean', False)

else:
    raise ValueError('not a boolean value in not')
"     
end function

------------------------------------------------------------------
attach not_op to __not__.

------------------------------------------------------------------
-- standard functions --
------------------------------------------------------------------
-- use this constructor to throw error exceptions with a string
-- as its argument

constructor Error with arity 1.

------------------------------------------------------------------
-- evaluates a term in the current term interpretation environment

function eval with item do return escape
"
global __retval__
item_val = state.symbol_table.lookup_sym('item')
__retval__ = walk(item_val)
"
end function

------------------------------------------------------------------
function length with lst do return escape
"
global __retval__
item_val = state.symbol_table.lookup_sym('lst')

if item_val[0] != 'list':
   raise ValueError(
   	 'length expected a list got {}'
	 .format(item_val[0]))

__retval__ = ('integer', len(item_val[1]))
"
end function

------------------------------------------------------------------
function exit with msg do escape
"
import sys

(MSGTYPE, msg_val) = state.symbol_table.lookup_sym('msg')
if MSGTYPE != 'string':
   raise ValueError('exit expected a string got {}'
   	 .format(MSGTYPE))

print(msg_val)
sys.exit(1)
"
end function
------------------------------------------------------------------

